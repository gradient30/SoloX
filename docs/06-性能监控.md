# 性能监控详解

## 🎯 监控指标概述

SoloX 提供全面的移动应用性能监控，涵盖 CPU、内存、网络、渲染、电池等关键指标。

## 📊 CPU 监控

### 监控原理

**Android**:
- 通过 `/proc/stat` 和 `/proc/{pid}/stat` 获取 CPU 使用率
- 计算应用进程和系统整体的 CPU 占用

**iOS**:
- 使用 `tidevice` 工具获取应用 CPU 使用率
- 通过系统 API 获取精确的 CPU 数据

### 数据格式

```json
{
  "appCpuRate": 25.5,    // 应用 CPU 使用率 (%)
  "systemCpuRate": 45.2  // 系统 CPU 使用率 (%)
}
```

### 使用示例

```python
# Python API
app_cpu, sys_cpu = apm.collectCpu()
print(f"应用 CPU: {app_cpu}%, 系统 CPU: {sys_cpu}%")

# HTTP API
curl "http://localhost:50003/apm/collect?platform=Android&deviceid=ca6bd5a5&pkgname=com.example.app&target=cpu"
```

### 性能分析

- **正常范围**: 应用 CPU < 30%，系统 CPU < 70%
- **性能问题**: 持续高 CPU 使用率可能导致发热和耗电
- **优化建议**: 
  - 减少主线程计算
  - 优化算法复杂度
  - 使用异步处理

## 🧠 内存监控

### 监控原理

**Android**:
- PSS (Proportional Set Size): 进程实际使用的物理内存
- Private Dirty: 进程私有的脏页内存
- 通过 `dumpsys meminfo` 获取详细内存信息

**iOS**:
- 使用 Instruments 相关 API 获取内存数据
- 监控应用的内存占用和系统可用内存

### 数据格式

```json
// 基础内存信息
{
  "pss": 156.8,      // PSS 内存 (MB)
  "private": 128.4,  // 私有内存 (MB)
  "total": 2048.0    // 总内存 (MB)
}

// 详细内存信息
{
  "java_heap": 45.2,     // Java 堆内存
  "native_heap": 23.1,   // Native 堆内存
  "code": 12.5,          // 代码段内存
  "stack": 2.3,          // 栈内存
  "graphics": 18.7,      // 图形内存
  "private_other": 15.4, // 其他私有内存
  "system": 8.9          // 系统内存
}
```

### 使用示例

```python
# 基础内存监控
pss, private, total = apm.collectMemory()
print(f"PSS: {pss}MB, Private: {private}MB")

# 详细内存监控
memory_detail = apm.collectMemoryDetail()
print(f"Java Heap: {memory_detail['java_heap']}MB")
```

### 内存泄漏检测

```python
import time

# 连续监控内存变化
memory_history = []
for i in range(60):  # 监控 1 分钟
    pss, _, _ = apm.collectMemory()
    memory_history.append(pss)
    time.sleep(1)

# 分析内存趋势
if len(memory_history) > 10:
    recent_avg = sum(memory_history[-10:]) / 10
    early_avg = sum(memory_history[:10]) / 10
    growth_rate = (recent_avg - early_avg) / early_avg * 100
    
    if growth_rate > 20:  # 内存增长超过 20%
        print(f"⚠️ 可能存在内存泄漏，增长率: {growth_rate:.2f}%")
```

## 🌐 网络监控

### 监控原理

**Android**:
- 通过 `/proc/net/dev` 获取网络接口流量
- 区分 WiFi 和移动网络流量
- 计算应用的上行和下行流量

**iOS**:
- 使用系统 API 获取网络统计信息
- 监控应用级别的网络使用情况

### 数据格式

```json
{
  "upflow": 1024.5,    // 上行流量 (KB)
  "downflow": 2048.3   // 下行流量 (KB)
}
```

### 使用示例

```python
# 网络流量监控
upflow, downflow = apm.collectNetwork(wifi=True)
print(f"上行: {upflow}KB, 下行: {downflow}KB")

# 网络速度计算
import time

# 第一次测量
up1, down1 = apm.collectNetwork()
time.sleep(1)
# 第二次测量
up2, down2 = apm.collectNetwork()

# 计算速度 (KB/s)
upload_speed = up2 - up1
download_speed = down2 - down1
print(f"上传速度: {upload_speed}KB/s, 下载速度: {download_speed}KB/s")
```

## 🎮 FPS 监控

### 监控原理

**Android**:
- **SurfaceView 模式**: 通过 `dumpsys SurfaceFlinger` 获取帧率
- **GfxInfo 模式**: 通过 `dumpsys gfxinfo` 获取渲染信息
- 计算卡顿帧数和丢帧率

**iOS**:
- 使用 Core Animation 相关 API
- 监控主线程的渲染性能

### 数据格式

```json
{
  "fps": 60,    // 当前帧率 (Hz)
  "jank": 2     // 卡顿次数
}
```

### 使用示例

```python
# FPS 监控
fps, jank = apm.collectFps()
print(f"FPS: {fps}, 卡顿: {jank}")

# 流畅度分析
def analyze_smoothness(fps_values):
    avg_fps = sum(fps_values) / len(fps_values)
    low_fps_count = sum(1 for fps in fps_values if fps < 30)
    
    if avg_fps >= 55:
        return "流畅"
    elif avg_fps >= 45:
        return "一般"
    else:
        return "卡顿"

# 收集 FPS 数据
fps_history = []
for _ in range(30):  # 收集 30 秒数据
    fps, _ = apm.collectFps()
    fps_history.append(fps)
    time.sleep(1)

smoothness = analyze_smoothness(fps_history)
print(f"应用流畅度: {smoothness}")
```

## 🔋 电池监控

### 监控原理

**Android**:
- 通过 `dumpsys battery` 获取电池状态
- 监控电量、温度、电流、电压等信息
- 计算功耗 (功率 = 电压 × 电流)

**iOS**:
- 使用 IOKit 框架获取电池信息
- 监控电池健康状态和充电状态

### 数据格式

```json
{
  "level": 85,        // 电量百分比 (%)
  "temperature": 32.5, // 温度 (°C)
  "current": -150,    // 电流 (mA，负值表示放电)
  "voltage": 4200,    // 电压 (mV)
  "power": 0.63       // 功耗 (W)
}
```

### 使用示例

```python
# 电池监控
battery_info = apm.collectBattery()
print(f"电量: {battery_info['level']}%")
print(f"温度: {battery_info['temperature']}°C")
print(f"功耗: {battery_info['power']}W")

# 电池健康分析
def analyze_battery_health(battery_data):
    level = battery_data['level']
    temperature = battery_data['temperature']
    power = battery_data['power']
    
    issues = []
    
    if level < 20:
        issues.append("电量过低")
    if temperature > 40:
        issues.append("温度过高")
    if power > 2.0:
        issues.append("功耗过大")
    
    return issues if issues else ["电池状态正常"]

health_issues = analyze_battery_health(battery_info)
print(f"电池健康: {', '.join(health_issues)}")
```

## 🎨 GPU 监控 (仅 Android)

### 监控原理

- 通过 `dumpsys gpu` 获取 GPU 使用率
- 监控 GPU 渲染负载和频率
- 分析图形性能瓶颈

### 数据格式

```json
{
  "gpu_usage": 45.2  // GPU 使用率 (%)
}
```

### 使用示例

```python
# GPU 监控 (仅 Android)
if platform == 'Android':
    gpu_usage = apm.collectGpu()
    print(f"GPU 使用率: {gpu_usage}%")
    
    if gpu_usage > 80:
        print("⚠️ GPU 负载过高，可能影响渲染性能")
```

## 💾 磁盘 I/O 监控

### 监控原理

- 监控应用的磁盘读写操作
- 分析 I/O 性能瓶颈
- 检测频繁的文件操作

### 使用示例

```python
# 磁盘 I/O 监控
disk_io = apm.collectDisk()
print(f"磁盘 I/O: {disk_io}")
```

## 🌡️ 温度监控

### 监控原理

- 监控设备各个传感器的温度
- 包括 CPU、电池、GPU 等组件温度
- 分析设备热管理状态

### 使用示例

```python
# 温度监控
thermal_data = apm.collectThermal()
print(f"设备温度: {thermal_data}")
```

## 📈 性能分析最佳实践

### 1. 监控策略

```python
# 全面性能监控
def comprehensive_monitoring(apm, duration=300):
    """全面性能监控"""
    start_time = time.time()
    performance_data = {
        'cpu': [],
        'memory': [],
        'network': [],
        'fps': [],
        'battery': []
    }
    
    while time.time() - start_time < duration:
        # 收集各项指标
        app_cpu, sys_cpu = apm.collectCpu()
        pss, private, total = apm.collectMemory()
        upflow, downflow = apm.collectNetwork()
        fps, jank = apm.collectFps()
        battery = apm.collectBattery()
        
        # 记录数据
        performance_data['cpu'].append({
            'timestamp': time.time(),
            'app_cpu': app_cpu,
            'sys_cpu': sys_cpu
        })
        
        performance_data['memory'].append({
            'timestamp': time.time(),
            'pss': pss,
            'private': private
        })
        
        # ... 记录其他数据
        
        time.sleep(1)  # 1秒采样间隔
    
    return performance_data
```

### 2. 异常检测

```python
def detect_performance_issues(performance_data):
    """性能问题检测"""
    issues = []
    
    # CPU 异常检测
    cpu_values = [d['app_cpu'] for d in performance_data['cpu']]
    avg_cpu = sum(cpu_values) / len(cpu_values)
    if avg_cpu > 50:
        issues.append(f"CPU 使用率过高: {avg_cpu:.1f}%")
    
    # 内存异常检测
    memory_values = [d['pss'] for d in performance_data['memory']]
    if len(memory_values) > 10:
        memory_growth = (memory_values[-1] - memory_values[0]) / memory_values[0] * 100
        if memory_growth > 30:
            issues.append(f"内存增长过快: {memory_growth:.1f}%")
    
    # FPS 异常检测
    fps_values = [d['fps'] for d in performance_data['fps']]
    low_fps_ratio = sum(1 for fps in fps_values if fps < 30) / len(fps_values)
    if low_fps_ratio > 0.2:
        issues.append(f"低帧率比例过高: {low_fps_ratio*100:.1f}%")
    
    return issues
```

### 3. 报告生成

```python
def generate_performance_report(performance_data, output_path):
    """生成性能报告"""
    import json
    from datetime import datetime
    
    report = {
        'timestamp': datetime.now().isoformat(),
        'summary': {
            'duration': len(performance_data['cpu']),
            'avg_cpu': sum(d['app_cpu'] for d in performance_data['cpu']) / len(performance_data['cpu']),
            'max_memory': max(d['pss'] for d in performance_data['memory']),
            'avg_fps': sum(d['fps'] for d in performance_data['fps']) / len(performance_data['fps'])
        },
        'issues': detect_performance_issues(performance_data),
        'raw_data': performance_data
    }
    
    with open(output_path, 'w') as f:
        json.dump(report, f, indent=2)
    
    print(f"性能报告已生成: {output_path}")
```

---

*下一步: [部署指南](./07-部署指南.md)*
